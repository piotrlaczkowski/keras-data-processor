{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf1f Welcome to Keras Data Processor - Preprocessing Power with TensorFlow Keras \ud83c\udf1f","text":"<p>Welcome to the Future of Data Preprocessing!</p> <p>Diving into the world of machine learning and data science, we often find ourselves tangled in the preprocessing jungle. Worry no more! Introducing a state-of-the-art data preprocessing model based on TensorFlow Keras and the innovative use of Keras preprocessing layers.</p> <p>Say goodbye to tedious data preparation tasks and hello to streamlined, efficient, and scalable data pipelines. Whether you're a seasoned data scientist or just starting out, this tool is designed to supercharge your ML workflows, making them more robust and faster than ever!</p>"},{"location":"#key-features","title":"\ud83d\udd11 Key Features:","text":"<ul> <li> <p>Automated Feature Engineering: Automatically detects and applies the optimal preprocessing steps for each feature type in your dataset.</p> </li> <li> <p>Customizable Preprocessing Pipelines: Tailor your preprocessing steps with ease, choosing from a wide range of options for numeric, categorical, and even complex feature crosses.</p> </li> <li> <p>Scalability and Efficiency: Designed for performance, handling large datasets with ease thanks to TensorFlow's powerful backend.</p> </li> <li> <p>Easy Integration: Seamlessly fits into your TensorFlow Keras models (as first layers of the mode), making it a breeze to go from raw data to trained model faster than ever.</p> </li> </ul>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting started:","text":"<p>We use poetry for handling dependencies so you will need to install it first. Then you can install the dependencies by running:</p> <p>To install dependencies:</p> <pre><code>poetry install\n</code></pre> <p>or to enter a dedicated env directly:</p> <pre><code>poetry shell\n</code></pre> <p>Then you can simply configure your preprocessor:</p>"},{"location":"#building-preprocessor","title":"\ud83d\udee0\ufe0f Building Preprocessor:","text":"<p>The simplest application of ths preprocessing model is as follows:</p> <pre><code>from kdp import PreprocessingModel\nfrom kdp import FeatureType\n\n# DEFINING FEATURES PROCESSORS\nfeatures_specs = {\n    # ======= NUMERICAL Features =========================\n    \"feat1\": FeatureType.FLOAT_NORMALIZED,\n    \"feat2\": FeatureType.FLOAT_RESCALED,\n    # ======= CATEGORICAL Features ========================\n    \"feat3\": FeatureType.STRING_CATEGORICAL,\n    \"feat4\": FeatureType.INTEGER_CATEGORICAL,\n    # ======= TEXT Features ========================\n    \"feat5\": FeatureType.TEXT,\n}\n\n# INSTANTIATE THE PREPROCESSING MODEL with your data\nppr = PreprocessingModel(\n    path_data=\"data/my_data.csv\",\n    features_specs=features_spec,\n)\n# construct the preprocessing pipelines\nppr.build_preprocessor()\n</code></pre> <p>This wil output:</p> <pre><code>{\n'model': &lt;Functional name=preprocessor, built=True&gt;,\n'inputs': {\n    'feat1': &lt;KerasTensor shape=(None, 1), dtype=float32, sparse=None, name=feat1&gt;,\n    'feat2': &lt;KerasTensor shape=(None, 1), dtype=float32, sparse=None, name=feat2&gt;,\n    'feat3': &lt;KerasTensor shape=(None, 1), dtype=string, sparse=None, name=feat3&gt;,\n    'feat4': &lt;KerasTensor shape=(None, 1), dtype=int32, sparse=None, name=feat4&gt;,\n    'feat5': &lt;KerasTensor shape=(None, 1), dtype=string, sparse=None, name=feat5&gt;\n    },\n'signature': {\n    'feat1': TensorSpec(shape=(None, 1), dtype=tf.float32, name='feat1'),\n    'feat2': TensorSpec(shape=(None, 1), dtype=tf.float32, name='feat2'),\n    'feat3': TensorSpec(shape=(None, 1), dtype=tf.string, name='feat3'),\n    'feat4': TensorSpec(shape=(None, 1), dtype=tf.int32, name='feat4'),\n    'feat5': TensorSpec(shape=(None, 1), dtype=tf.string, name='feat5')\n    },\n'output_dims': 45\n}\n</code></pre> <p>This will result in the following preprocessing steps:</p> <p> </p> <p>Success</p> <p>You can define the preprocessing model with the <code>features_specs</code> dictionary, where the keys are the feature names and the values are the feature types. The model will automatically apply the appropriate preprocessing steps based on the feature type.</p> <pre><code>You have access to several layers of customization per feature type, such as normalization, rescaling, or even definition of custom preprocessing steps.\n\n\ud83d\udc40 See [Defining Features](features.md) for more details.\n</code></pre> <p>Info</p> <p>You can use the preprocessing model independently to preprocess your data or integrate it into your Keras model as the first layer, see \ud83d\udc40 Integrations</p>"},{"location":"contributing/","title":"\ud83d\udcbb Contributing: Join the Preprocessing Revolution! \ud83d\udee0\ufe0f","text":"<p>Eager to contribute? Great! We're excited to welcome new contributors to our project. Here's how you can get involved:</p>"},{"location":"contributing/#new-ideas-features-requests","title":"\ud83d\udca1 New Ideas / Features Requests","text":"<p>If you wan't to request a new feature or you have detected an issue, please use the following link: ISSUES</p>"},{"location":"contributing/#getting-started","title":"\ud83d\ude80 Getting Started:","text":"<ul> <li> <p> Fork the Repository: Visit our GitHub page, fork the repository, and clone it to your local machine.</p> </li> <li> <p> Set Up Your Environment: Make sure you have TensorFlow, Loguru, and all necessary dependencies installed.</p> </li> <li> <p> Make sure you have installed the pre-commit hook locally</p> </li> </ul> <p>??? installation-guide   Before using pre-commit hook you need to install it in your python environment.</p> <pre><code>    ```bash\n    conda install -c conda-forge pre-commit\n    ```\n\n    go to the root folder of this repository, activate your venv and use the following command:\n\n    ```bash\n    pre-commit install\n    ```\n</code></pre> <ul> <li> <p> Create a new branch to package your code</p> </li> <li> <p> Use standarized commit message:</p> </li> </ul> <p><code>{LABEL}(KDP): {message}</code></p> <p>This is very important for the automatic releases (semantic release) and to have clean history on the master branch.</p> <p>??? Labels-types</p> <pre><code>    | Label    | Usage                                                                                                                                                                                                                                             |\n    | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n    | break    | `break` is used to identify changes related to old compatibility or functionality that breaks the current usage (major)                                                                                                                           |\n    | feat     | `feat` is used to identify changes related to new backward-compatible abilities or functionality (minor)                                                                                                                                          |\n    | init     | `init` is used to indentify the starting related to the project (minor)                                                                                                                                                                           |\n    | enh      | `enh` is used to indentify changes related to amelioration of abilities or functionality (patch)                                                                                                                                                  |\n    | build    | `build` (also known as `chore`) is used to identify **development** changes related to the build system (involving scripts, configurations, or tools) and package dependencies (patch)                                                            |\n    | ci       | `ci` is used to identify **development** changes related to the continuous integration and deployment system - involving scripts, configurations, or tools (minor)                                                                                |\n    | docs     | `docs`  is used to identify documentation changes related to the project; whether intended externally for the end-users or internally for the developers (patch)                                                                                  |\n    | perf     | `perf`  is used to identify changes related to backward-compatible **performance improvements** (patch)                                                                                                                                           |\n    | refactor | `refactor` is used to identify changes related to modifying the codebase, which neither adds a feature nor fixes a bug - such as removing redundant code, simplifying the code, renaming variables, etc.&lt;br /&gt;i.e. handy for your wip ; ) (patch) |\n    | style    | `style`  is used to identify **development** changes related to styling the codebase, regardless of the meaning - such as indentations, semi-colons, quotes, trailing commas, and so on (patch)                                                   |\n    | test     | `test` is used to identify **development** changes related to tests - such as refactoring existing tests or adding new tests. (minor)                                                                                                             |\n    | fix      | `fix`  is used to identify changes related to backward-compatible bug fixes. (patch)                                                                                                                                                              |\n    | ops      | `ops` is used to identify changes related to deployment files like `values.yml`, `gateway.yml,` or `Jenkinsfile` in the **ops** directory. (minor)                                                                                                |\n    | hotfix   | `hotfix` is used to identify **production** changes related to backward-compatible bug fixes (patch)                                                                                                                                              |\n    | revert   | `revert` is used to identify backward changes (patch)                                                                                                                                                                                             |\n    | maint    | `maint` is used to identify **maintenance** changes related to project (patch)                                                                                                                                                                    |\n</code></pre> <ul> <li> Create your first Merge Request (MR) as soon as possible.</li> </ul> <p>Merge requests will be responsible for semantic-release storytelling and so use them wisely! The changelog report generated automatically will be based on your commits merged into main branch and should cover all the thins you did for the project, as an example:</p> <ul> <li> Separate your merge requests based on LABEL or functionality if you are working on <code>feat</code> label</li> </ul> <p>This about what part of feature you are working on, (messages) i.e.:</p> <pre><code>    - `initializaing base pre-processing code`\n    - `init repo structure`\n    - `adding pre-processing unit-tests`\n</code></pre> <ul> <li> Once the code is ready create a Merge Request (MR) into the DEV branch with a proper naming convention</li> </ul> <p>The name of your MR should follow the same exact convention as your commits (we have a dedicated check for this in the CI):</p> <pre><code>    `{LABEL}(KDP): {message}`\n</code></pre> <ul> <li> <p> Use small Merge Requests but do them more ofthen &lt; 400 ligns for quicker and simple review and not the whole project !</p> </li> <li> <p> Ask for a Code Review !</p> </li> <li> <p> Once your MR is approved, solve all your unresolved conversation and pass all the CI check before you can merge it.</p> </li> <li> <p> All the Tests for your code should pass -&gt; REMEMBER NO TESTS = NO MERGE \ud83d\udea8</p> </li> </ul>"},{"location":"features/","title":"Defining Features for Preprocessing \ud83c\udf1f","text":"<p>Customize the preprocessing pipeline by setting up a dictionary that maps feature names to their respective types, tailored to your specific requirements.</p>"},{"location":"features/#numeric-features","title":"\ud83d\udcaf Numeric Features","text":"<p>Explore various methods to define numerical features tailored to your needs:</p> \u2139\ufe0f Simple Declaration\ud83d\udd27 Using FeatureType\ud83d\udcaa Custom NumericalFeature <pre><code>features_specs = {\n    \"feat1\": \"float\",\n    \"feat2\": \"FLOAT\",\n    \"feat3\": \"FLOAT_NORMALIZED\",\n    \"feat3\": \"FLOAT_RESCALED\",\n    ...\n}\n</code></pre> <p>Utilize predefined preprocessing configurations with <code>FeatureType</code>.</p> <pre><code>from kdp.features import FeatureType\n\nfeatures_specs = {\n    \"feat1\": FeatureType.FLOAT_NORMALIZED,\n    \"feat2\": FeatureType.FLOAT_RESCALED,\n    ...\n}\n</code></pre> <p>Available <code>FeatureType</code> options:</p> <ul> <li>FLOAT</li> <li>FLOAT_NORMALIZED</li> <li>FLOAT_RESCALED</li> <li>FLOAT_DISCRETIZED</li> </ul> <p>Customize preprocessing by passing specific parameters to <code>NumericalFeature</code>.</p> <pre><code>from kdp.features import NumericalFeature\n\nfeatures_specs = {\n    \"feat3\": NumericalFeature(\n        name=\"feat3\",\n        feature_type=FeatureType.FLOAT_DISCRETIZED,\n        bin_boundaries=[(1, 10)],\n    ),\n    \"feat4\": NumericalFeature(\n        name=\"feat4\",\n        feature_type=FeatureType.FLOAT,\n    ),\n    ...\n}\n</code></pre> <p>Here's how the numeric preprocessing pipeline looks:</p> <p></p>"},{"location":"features/#categorical-features","title":"\ud83d\udc08\u200d\u2b1b Categorical Features","text":"<p>Define categorical features flexibly:</p> \u2139\ufe0f Simple Declaration\ud83d\udd27 Using FeatureType\ud83d\udcaa Custom CategoricalFeature <pre><code>features_specs = {\n    \"feat1\": \"INTEGER_CATEGORICAL\",\n    \"feat2\": \"STRING_CATEGORICAL\",\n    \"feat3\": \"string_categorical\",\n    ...\n}\n</code></pre> <p>Leverage default configurations with <code>FeatureType</code>.</p> <pre><code>from kdp.features import FeatureType\n\nfeatures_specs = {\n    \"feat1\": FeatureType.INTEGER_CATEGORICAL,\n    \"feat2\": FeatureType.STRING_CATEGORICAL,\n    ...\n}\n</code></pre> <p>Available <code>FeatureType</code> options:</p> <ul> <li>STRING_CATEGORICAL</li> <li>INTEGER_CATEGORICAL</li> </ul> <p>Tailor feature processing by specifying properties in <code>CategoricalFeature</code>.</p> <pre><code>from kdp.features\nfrom kdp.features import CategoricalFeature\n\nfeatures_specs = {\n    \"feat1\": CategoricalFeature(\n        name=\"feat7\",\n        feature_type=FeatureType.INTEGER_CATEGORICAL,\n        embedding_size=100,\n    ),\n    \"feat2\": CategoricalFeature(\n        name=\"feat2\",\n        feature_type=FeatureType.STRING_CATEGORICAL,\n    ),\n    ...\n}\n</code></pre> <p>See how the categorical preprocessing pipeline appears:</p> <p></p>"},{"location":"features/#text-features","title":"\ud83d\udcdd Text Features","text":"<p>Customize text features in multiple ways to fit your project's demands:</p> \u2139\ufe0f Simple Declaration\ud83d\udd27 Using FeatureType\ud83d\udcaa Custom TextFeature <pre><code>features_specs = {\n    \"feat1\": \"text\",\n    \"feat2\": \"TEXT\",\n    ...\n}\n</code></pre> <p>Use <code>FeatureType</code> for automatic default preprocessing setups.</p> <pre><code>from kdp.features import FeatureType\n\nfeatures_specs = {\n    \"feat1\": FeatureType.TEXT,\n    \"feat2\": FeatureType.TEXT,\n    ...\n}\n</code></pre> <p>Available <code>FeatureType</code> options:</p> <ul> <li>TEXT</li> </ul> <p>Customize text preprocessing by passing specific arguments to <code>TextFeature</code>.</p> <pre><code>from kdp.features import TextFeature\n\nfeatures_specs = {\n    \"feat1\": TextFeature(\n        name=\"feat2\",\n        feature_type=FeatureType.TEXT,\n        max_tokens=100,\n        stop_words=[\"stop\", \"next\"],\n    ),\n    \"feat2\": TextFeature(\n        name=\"feat2\",\n        feature_type=FeatureType.TEXT,\n    ),\n    ...\n}\n</code></pre> <p>Here's how the text feature preprocessing pipeline looks:</p> <p></p>"},{"location":"features/#cross-features","title":"\u274c Cross Features","text":"<p>Combine two or more features to create complex cross feature interactions:</p> <p>Info</p> <p>To implement cross features, specify a list of feature tuples in the <code>PreprocessingModel</code> like so:</p> <pre><code>```python\nfrom kdp.processor import PreprocessingModel\n\nppr = PreprocessingModel(\n    path_data=\"data/data.csv\",\n    features_specs={\n        \"feat6\": FeatureType.STRING_CATEGORICAL,\n        \"feat7\": FeatureType.INTEGER_CATEGORICAL,\n    },\n    feature_crosses=[(\"feat6\", \"feat7\", 5)],\n)\n```\n</code></pre> <p>Example cross feature between INTEGER_CATEGORICAL and STRING_CATEGORICAL:</p> <p></p>"},{"location":"features/#custom-preprocessing-steps","title":"\ud83d\ude80 Custom Preprocessing Steps","text":"<p>If you require even more customization, you can define custom preprocessing steps using the <code>Feature</code> class, using <code>preprocessors</code> attribute.</p> <p>Info</p> <p>The <code>preprocessors</code> attribute accepts a list of methods defined in <code>PreprocessorLayerFactory</code>.</p> <pre><code>from kdp.features import Feature\nfrom kdp.layers_factory import PreprocessorLayerFactory\n\nfeatures_specs = {\n    \"feat1\": FeatureType.FLOAT_NORMALIZED,\n    \"feat2\": Feature(\n        name=\"custom_feature_pipeline\",\n        feature_type=FeatureType.FLOAT_NORMALIZED,\n        preprocessors=[\n            PreprocessorLayerFactory.rescaling_layer,\n            PreprocessorLayerFactory.normalization_layer,\n\n        ],\n        # leyers required kwargs\n        scale=1,\n    )\n}\n</code></pre> <p>Here's how the text feature preprocessing pipeline looks:</p> <p></p> <p>The full list of availble layers can be found: Preprocessing Layers Factory</p>"},{"location":"integrations/","title":"\ud83d\udd17 Integrating Preprocessing Model with other Keras Model:","text":"<p>You can then easily ingetrate this model into your keras model as the first layer:</p>"},{"location":"integrations/#example-1-using-the-preprocessing-model-as-the-first-layer-of-a-sequential-model","title":"Example 1: Using the Preprocessing Model as the first layer of a Sequential Model","text":"<pre><code>class FunctionalModelWithPreprocessing(tf.keras.Model):\n    def __init__(self, preprocessing_model: tf.keras.Model) -&gt; None:\n        \"\"\"Initialize the user model.\n\n        Args:\n            preprocessing_model (tf.keras.Model): The preprocessing model.\n        \"\"\"\n        super().__init__()\n        self.preprocessing_model = preprocessing_model\n\n        # Dynamically create inputs based on the preprocessing model's input shape\n        inputs = {\n            name: tf.keras.Input(shape=shape[1:], name=name)\n            for name, shape in self.preprocessing_model.input_shape.items()\n        }\n\n        # You can use the preprocessing model directly in the functional API.\n        x = self.preprocessing_model(inputs)\n\n        # Define the dense layer as part of the model architecture\n        output = tf.keras.layers.Dense(\n            units=128,\n            activation=\"relu\",\n        )(x)\n\n        # Use the Model's functional API to define inputs and outputs\n        self.model = tf.keras.Model(inputs=inputs, outputs=output)\n\n    def call(self, inputs: dict[str, tf.Tensor]) -&gt; tf.Tensor:\n        \"\"\"Call the item model with the given inputs.\"\"\"\n        return self.model(inputs)\n\n# not define the full model with builting preprocessing layers:\nfull_model = FunctionalModelWithPreprocessing(\n    preprocessing_model=ppr.model,\n)\n</code></pre>"},{"location":"layers_factory/","title":"\ud83c\udfed Preprocessing Layers Factory","text":"<p>You can find all availble layers in the <code>PreprocessorLayerFactory</code> class:</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>class PreprocessorLayerFactory:\n    @staticmethod\n    def create_layer(layer_class, name: str = None, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a layer, automatically filtering kwargs based on the provided layer_class.\n\n        Args:\n            layer_class: The class of the layer to be created.\n            name: The name of the layer. Optional.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the specified layer_class.\n        \"\"\"\n        # Get the signature of the layer class constructor\n        constructor_params = inspect.signature(layer_class.__init__).parameters\n\n        # Filter kwargs to only include those that the constructor can accept\n        filtered_kwargs = {key: value for key, value in kwargs.items() if key in constructor_params}\n\n        # Add the 'name' argument\n        filtered_kwargs[\"name\"] = name\n\n        # Create an instance of the layer class with the filtered kwargs\n        layer_instance = layer_class(**filtered_kwargs)\n        return layer_instance\n\n    # Example usage for specific layer types\n    @staticmethod\n    def normalization_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a Normalization layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the Normalization layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.Normalization,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def discretization_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a Discretization layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the Discretization layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.Discretization,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def rescaling_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a Rescaling layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the Rescaling layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.Rescaling,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def embedding_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a Embedding layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the Embedding layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.Embedding,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def category_encoding_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a CategoryEncoding layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the CategoryEncoding layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.CategoryEncoding,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def string_lookup_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a StringLookup layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the StringLookup layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.StringLookup,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def integer_lookup_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a IntegerLookup layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the IntegerLookup layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.IntegerLookup,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def crossing_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a HashedCrossing layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the HashedCrossing layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.HashedCrossing,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def flatten_layer(name: str = \"flatten\", **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a Flatten layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the Flatten layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.Flatten,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def concat_layer(name: str = \"concat\", **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a Concatenate layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the Concatenate layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.Concatenate,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def text_preprocessing_layer(name: str = \"text_preprocessing\", **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a TextPreprocessingLayer layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the TextPreprocessingLayer layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=TextPreprocessingLayer,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def text_vectorization_layer(name: str = \"text_vectorization\", **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a TextVectorization layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the TextVectorization layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=tf.keras.layers.TextVectorization,\n            name=name,\n            **kwargs,\n        )\n\n    @staticmethod\n    def cast_to_float32_layer(name: str = \"cast_to_float32\", **kwargs) -&gt; tf.keras.layers.Layer:\n        \"\"\"Create a CastToFloat32Layer layer.\n\n        Args:\n            name: The name of the layer.\n            **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n        Returns:\n            An instance of the CastToFloat32Layer layer.\n        \"\"\"\n        return PreprocessorLayerFactory.create_layer(\n            layer_class=CastToFloat32Layer,\n            name=name,\n            **kwargs,\n        )\n</code></pre> <p>handler: python options: show_root_heading: false show_source: false heading_level: 3</p>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.cast_to_float32_layer","title":"<code>cast_to_float32_layer(name='cast_to_float32', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a CastToFloat32Layer layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> <code>'cast_to_float32'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the CastToFloat32Layer layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef cast_to_float32_layer(name: str = \"cast_to_float32\", **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a CastToFloat32Layer layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the CastToFloat32Layer layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=CastToFloat32Layer,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.category_encoding_layer","title":"<code>category_encoding_layer(name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a CategoryEncoding layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the CategoryEncoding layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef category_encoding_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a CategoryEncoding layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the CategoryEncoding layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.CategoryEncoding,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.concat_layer","title":"<code>concat_layer(name='concat', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a Concatenate layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> <code>'concat'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the Concatenate layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef concat_layer(name: str = \"concat\", **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a Concatenate layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the Concatenate layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.Concatenate,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.create_layer","title":"<code>create_layer(layer_class, name=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a layer, automatically filtering kwargs based on the provided layer_class.</p> <p>Parameters:</p> Name Type Description Default <code>layer_class</code> <p>The class of the layer to be created.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Optional.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the specified layer_class.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef create_layer(layer_class, name: str = None, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a layer, automatically filtering kwargs based on the provided layer_class.\n\n    Args:\n        layer_class: The class of the layer to be created.\n        name: The name of the layer. Optional.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the specified layer_class.\n    \"\"\"\n    # Get the signature of the layer class constructor\n    constructor_params = inspect.signature(layer_class.__init__).parameters\n\n    # Filter kwargs to only include those that the constructor can accept\n    filtered_kwargs = {key: value for key, value in kwargs.items() if key in constructor_params}\n\n    # Add the 'name' argument\n    filtered_kwargs[\"name\"] = name\n\n    # Create an instance of the layer class with the filtered kwargs\n    layer_instance = layer_class(**filtered_kwargs)\n    return layer_instance\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.crossing_layer","title":"<code>crossing_layer(name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a HashedCrossing layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the HashedCrossing layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef crossing_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a HashedCrossing layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the HashedCrossing layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.HashedCrossing,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.discretization_layer","title":"<code>discretization_layer(name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a Discretization layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the Discretization layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef discretization_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a Discretization layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the Discretization layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.Discretization,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.embedding_layer","title":"<code>embedding_layer(name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a Embedding layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the Embedding layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef embedding_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a Embedding layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the Embedding layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.Embedding,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.flatten_layer","title":"<code>flatten_layer(name='flatten', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a Flatten layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> <code>'flatten'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the Flatten layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef flatten_layer(name: str = \"flatten\", **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a Flatten layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the Flatten layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.Flatten,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.integer_lookup_layer","title":"<code>integer_lookup_layer(name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a IntegerLookup layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the IntegerLookup layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef integer_lookup_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a IntegerLookup layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the IntegerLookup layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.IntegerLookup,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.normalization_layer","title":"<code>normalization_layer(name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a Normalization layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the Normalization layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef normalization_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a Normalization layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the Normalization layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.Normalization,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.rescaling_layer","title":"<code>rescaling_layer(name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a Rescaling layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the Rescaling layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef rescaling_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a Rescaling layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the Rescaling layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.Rescaling,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.string_lookup_layer","title":"<code>string_lookup_layer(name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a StringLookup layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the StringLookup layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef string_lookup_layer(name: str, **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a StringLookup layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the StringLookup layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.StringLookup,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.text_preprocessing_layer","title":"<code>text_preprocessing_layer(name='text_preprocessing', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a TextPreprocessingLayer layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> <code>'text_preprocessing'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the TextPreprocessingLayer layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef text_preprocessing_layer(name: str = \"text_preprocessing\", **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a TextPreprocessingLayer layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the TextPreprocessingLayer layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=TextPreprocessingLayer,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"layers_factory/#kdp.layers_factory.PreprocessorLayerFactory.text_vectorization_layer","title":"<code>text_vectorization_layer(name='text_vectorization', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a TextVectorization layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> <code>'text_vectorization'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the TextVectorization layer.</p> Source code in <code>kdp/layers_factory.py</code> <pre><code>@staticmethod\ndef text_vectorization_layer(name: str = \"text_vectorization\", **kwargs) -&gt; tf.keras.layers.Layer:\n    \"\"\"Create a TextVectorization layer.\n\n    Args:\n        name: The name of the layer.\n        **kwargs: Additional keyword arguments to pass to the layer constructor.\n\n    Returns:\n        An instance of the TextVectorization layer.\n    \"\"\"\n    return PreprocessorLayerFactory.create_layer(\n        layer_class=tf.keras.layers.TextVectorization,\n        name=name,\n        **kwargs,\n    )\n</code></pre>"}]}